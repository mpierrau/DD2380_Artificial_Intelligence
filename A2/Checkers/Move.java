import java.util.StringTokenizer;
import java.util.Vector;

/**
 * Represents a move.
 *
 * In general, you should regard this as an opaque structure that exists in the
 * GameState you obtain from FindPossibleMoves.
 *
 * The methods IsNormal(), IsJump() and IsEOG() might be useful.
 *
 * You can probably ignore the rest of the class.
 * Note that "jump" refers to capturing a piece by jumping over it.
 */
public class Move {
	/**
	 * Constants for different types of moves.
	 *
	 */
  public static final int MOVE_JUMP   = 1;  // A single jump (numbers above this will represent multiple jumps)
  public static final int MOVE_NORMAL = 0;  // A normal move
  public static final int MOVE_BOG  = -1; // Beginning of game
  public static final int MOVE_RW   = -2; // Red wins => end of game
  public static final int MOVE_WW   = -3; // White wins => end of game
  public static final int MOVE_DRAW   = -4; // Draw => end of game
  public static final int MOVE_NULL   = -5; // A null move
	
  static final String cDelimiter = "_";

  private int mType;
  private Vector<Integer> mData = new Vector<Integer>();

  /**
   * Constructs a specific type of move.
   *
   * @param moveType
   *      moveType should be one of MOVE_BOG, MOVE_RW, MOVE_WW or MOVE_DRAW
   * @return
   */
  public Move(int moveType) {
    this.mType = moveType;
  }

  /**
   * Constructs a MOVE_BOG move.
   */
  public Move() {
    this(MOVE_BOG);
  }

  /**
   * Constructs a normal move (not a jump).
   *
   * @param p1 the starting square
   * @param p2 the ending square
   */
  public Move(int p1, int p2) {
    this(MOVE_NORMAL);

    assert (this.mData.size() == 0);

    this.mData.add(p1);
    this.mData.add(p2);
  }

  /**
   * Constructs a jump move, which may consist of a series of jumps.
   *
   * @param pData a series of squares which form the sequence of jumps
   */
  public Move(Vector<Integer> pData, int len) {
    this.mType = len - 1;
    this.mData.setSize(0);
    for (int i = 0; i < len; i++) {
      this.mData.add(pData.get(i));
    }
  }

  /**
   * Reconstructs the move from a string.
   *
   * @param pString a string, which should have been previously generated by 
   * 		ToMessage(), or obtained from the server.
   */
  public Move(final String pString) {
    StringTokenizer st = new StringTokenizer(pString, Move.cDelimiter);
    String str = st.nextToken();

    this.mType = Integer.parseInt(str);

    int lLen = 0;

    if (mType == MOVE_NORMAL) {
      lLen = 2;
    } else if (mType > 0) {
      lLen = mType + 1;
    }

    if (lLen > 12 || mType < MOVE_NULL) {
      mType = MOVE_NULL;
      return;
    }

    this.mData.setSize(lLen);

    for (int i = 0; i < lLen; i++) {
      int lCell;

      str = st.nextToken();
      lCell = Integer.parseInt(str);

      if (lCell < 0 || lCell > 31) {
        this.mType = MOVE_NULL;
        break;
      }

      this.mData.set(i, lCell);
    }

    if (st.hasMoreTokens()) {
      this.mType = MOVE_NULL;
    }
  }

  /**
   * Creates a deep copy of a Move.
   */
  public Move(Move m) {
    this.mType = m.mType;
    this.mData = new Vector<Integer>(m.mData);
  }

  /**
   * Creates a reverse version of this move.
   * 
   * By "reverse" we mean to say that red player becomes white player, and
   * vice versa.
   */
  public Move reversed() {
    Move result = new Move(this.mType);

    if (this.isRedWin()) {
      result.mType = MOVE_WW;
    } else if (this.isWhiteWin()) {
      result.mType = MOVE_RW;
    }

    for (int i = 0; i < this.mData.size(); i++) {
      result.mData.add(31 - this.mData.elementAt(i));
    }
    return result;
  }

  /**
   * Checks if the movement is null or invalid.
   */
  public boolean isNull() {
    return (this.mType == MOVE_NULL);
  }

  /**
   * Checks if the movement marks beginning of game.
   */
  public boolean isBOG() {
    return (this.mType == MOVE_BOG);
  }

  /**
   * Checks if the movement marks end of game.
   */
  public boolean isEOG() {
    return (this.mType < MOVE_BOG);
  }

  /**
   * Checks if the game ended in red win.
   */
  public boolean isRedWin() {
    return (this.mType == MOVE_RW);
  }

  /**
   * Checks if the game ended in white win.
   */
  public boolean isWhiteWin() {
    return (this.mType == MOVE_WW);
  }

  /**
   * Checks if the game ended in draw.
   */
  public boolean isDraw() {
    return (this.mType == MOVE_DRAW);
  }

  /**
   * Checks if the movement is a jump.
   */
  public boolean isJump() {
    return (this.mType > 0);
  }

  /**
   * Checks if the movement is a normal move.
   */
  public boolean isNormal() {
    return (this.mType == MOVE_NORMAL);
  }

  /**
   * Gets the type of the move.
   */
  public int getType() {
    return this.mType;
  }

  /**
   * Gets (for normal moves and jumps) the length of the move sequence.
   */
  public int length() {
    return this.mData.size();
  }

  /**
   * Gets the pN-th square in the move sequence.
   */
  public int at(int pN) {
    return this.mData.elementAt(pN);
  }

  /**
   * Converts the move to a string so that it can be sent to the other player.
   */
  public String toMessage() {
    String lStream = new String();
    lStream = lStream + mType;

    for (int i = 0; i < this.mData.size(); i++) {
      lStream = lStream + cDelimiter + this.mData.elementAt(i);
    }

    return lStream;
  }

  @Override
  public String toString() {
    if (this.mType == MOVE_WW) {
      return "WW";
    }
    if (this.mType == MOVE_RW) {
      return "RW";
    }
    if (this.mType == MOVE_DRAW) {
      return "DRAW";
    }
    if (this.mType == MOVE_BOG) {
      return "BOG";
    }
    if (this.isNull()) {
      return "NULL";
    }

    String lStream = new String();
    String delimiter = isNormal() ? "-" : "x";

    assert (this.mData.size() > 0);

    // Concatenate all the cell numbers
    lStream = lStream + this.mData.elementAt(0);

    for (int i = 1; i < this.mData.size(); i++) {
      lStream = lStream + delimiter + this.mData.elementAt(i);
    }

    return lStream;
  }

  /**
   * Checks if the two objects represent the same move.
   */
  public boolean equals(final Move pRH) {
    if (this.mType != pRH.mType) {
      return false;
    }

    if (this.mData.size() != pRH.mData.size()) {
      return false;
    }

    for (int i = 0; i < this.mData.size(); i++) {
      if (this.mData.elementAt(i) != pRH.mData.elementAt(i)) {
        return false;
      }
    }

    return true;
  }
}
